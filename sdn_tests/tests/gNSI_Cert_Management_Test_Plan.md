# Overview

The gNSI Certificate Management microservice consists of two RPCs. Those RPC can be called in separation as they encapsulate a complete workflow.

The gNSI Certificate Management API allows for management of 3 types of entities, namely:

-   A Certificate (with private key) used by the P4RT and the gNMI/gNOI/gNSI gRPC-based microservices.
-   A Certificate Authority (CA) Trust Bundle - a collection of certificates that is used by the P4RT and the gNMI/gNOI/gNSI gRPC-based microservices to validate the certificates presented by the microservice clients during connection establishment.
-   A Certificate Revocation List (CRL) - a collection of certificates that should be rejected during gRPC connection establishment as they are considered compromised

The API allows for installation and rotation of multiple certificates, CA trust bundles and CRLs but only one certificate, one CA trust bundle and one CRL is used by the gRPC-based services on the switch.\
Which certificate, CA trust bundle and CRL is used is controlled by configuring appropriate leaves in the OpenConfig model exposed to the world by the gNMI server. When the switch boots for the first time this configuration defaults to:

-   `server` as the ID of the certificate/private key to be used by the P4RT and the gNMI/gNOI/gNSI gRPC-based microservices
-   `ca` as the ID of the CA trust bundle to be used by the P4RT and the gNMI/gNOI/gNSI gRPC-based microservices
-   `crl` as the ID of the CRL to be used by the P4RT and the gNMI/gNOI/gNSI gRPC-based microservices

Those IDs have to be used when calling the `gnsi.Rotate()` RPC as only existing entities can be rotated.

Those IDs cannot be used when calling the `gnsi.Install()` RPC as only non-existing entities can be installed.

# Testbed/Infrastructure

Every test runs on a machine that is connected to the device under test (DUT). Each test creates two stubs that talk to two different gRPC-based services:

-   gNMI
-   gNSI Certificate Management

The gNSI Certificate Management microserver is the one that is being tested while the gNMI microserver is used to verify that the changes to the credentials made via the gNSI microservice are actually made.


# Test credentials

The tests  require "good" and "bad" credentials to verify all scenarios. That includes:

-   "Good" and "bad" switch certificates (with private keys)
-   "Good" and "bad" Certificate Authority trust bundles
-   "Good" and "bad" Certificate Revocation Lists

## Bad credentials

The "bad" credentials can be generated locally on the test machine before (or during) the tests or can be baked-in into the source code of the tests as they are expected to be unusable.

## Good credentials

For the "good" credentials there are two options:

1.  Use the real Google's Certificate Authority  signed credentials
1.  Use the self-signed credentials generated locally on the test machine

### Real credentials

The "good" credentials should be the "real" certificates generated and signed by Google's Certificate Authority as they will stay on the switch after the test.

How to get access to those credentials?

-   Certificate Authority trust bundle is not a secret and can be downloaded from a code repository or the switch
-   Server certificate is not a secret
    -   It can be downloaded from a code repository (assuming the certificates for testbeds are stored in the code repository)
    -   It can be downloaded from the switch (if the test has the root SSH access to the switch)
    -
-   Server private key **is a secret**
    -   It can be downloaded from the switch (if the test has the root SSH access to the switch)
    -   It can be requested from the Google's Certificate Authority

### Self-signed credentials

In theory self-signed credentials generated by the test could be the "good" credentials as both stubs created by the test and the gRPC server on the switch can be configured to use them to authenticate the connection(s). However, without access to the "real" credentials the test is not able to revert the self-signed credentials and effectively leaves the switch in unusable condition.

This complication makes the self-signed credentials usable only for a subset of the test cases.

# Verification if credentials are active

The streaming nature of the `Rotate()` RPC allows for testing the installed credentials and to revert to the last known good state if something went wrong.

The general procedure is a follows:

1.  A stream is opened when the `Rotate()` RPC is executed
1.  A message requesting change of a credential is sent from the client to the server
1.  The server changes the credential and activates it
1.  The client verifies the change by creating a new connection using the new credentials
1.  If the client is happy with the change it sends a `Finalize` request to the server that makes the change permanent, closes the connection and cleans up
1.  If the client is not happy with the change it closes the connection without sending any new message which causes the server to revert to the previous working state

Most of gNMI, gNOI or gNSI RPCs can be used to create a new connection described in point 4 but it seems that the easiest one is:

<table>
  <thead>
    <tr>
      <th><p><pre>
gNMI.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)
</pre></p></th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>

# Scenarios

There are two RPCs that need to be tested:

-   `Rotate()`
-   `Install()`

The following sub-chapters present test cases covering all use scenarios.

## Rotate()

This RPC is used to replace an existing entity (certificate, CA trust bundle or CRL).

### Open stream and close

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Rotate()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.CloseSend()</code></td>
      <td>Success - the client->server stream is closed</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: premature stream closure and the <code>stream</code> is closed.</td>
    </tr>
  </tbody>
</table>

### Open stream, send empty request

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Rotate()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<empty request>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: missing information and the <code>stream</code> is closed.</td>
    </tr>
  </tbody>
</table>

### Open stream, send incomplete upload certificate request

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Rotate()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<incomplete UploadRequest>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: missing information and the <code>stream</code> is closed.</td>
    </tr>
  </tbody>
</table>

There are 7 fields in the `UploadRequest.Entity `message:

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><p><pre>
id
</pre></p></td>
      <td>A string identifying the entity to be replaced.<br>
Only existing entities can be rotated.<br>
An entity is installed by calling the <code>Install()</code> RPC with a non-existing ID.<br>
In the default configuration it should be <code>server.</code></td>
    </tr>
    <tr>
      <td><p><pre>
version
</pre></p></td>
      <td>The version of the entity. It has to be unique. A good unique version can be generated using the current timestamp.</td>
    </tr>
    <tr>
      <td><p><pre>
created_on
</pre></p></td>
      <td>A timestamp of the moment in time when the entity was created</td>
    </tr>
    <tr>
      <td><p><pre>
certificate.type
</pre></p></td>
      <td>The type of the certificate. For example: CT_X509</td>
    </tr>
    <tr>
      <td><p><pre>
certificate.encoding
</pre></p></td>
      <td>The encoding of the certificate. For example: CE_PEM</td>
    </tr>
    <tr>
      <td><p><pre>
certificate.certificate
</pre></p></td>
      <td>Bytes representing the PEM-encoded certificate</td>
    </tr>
    <tr>
      <td><p><pre>
certificate.private_key
</pre></p></td>
      <td>Bytes representing the PEM-encoded private key</td>
    </tr>
  </tbody>
</table>

This test should validate the following combinations of missing information:

<table>
  <thead>
    <tr>
      <th>case</th>
      <th><p><pre>
id
</pre></p></th>
      <th><p><pre>
version
</pre></p></th>
      <th><p><pre>
created
</pre></p></th>
      <th><p><pre>
type
</pre></p></th>
      <th><p><pre>
enc
</pre></p></th>
      <th><p><pre>
cert
</pre></p></th>
      <th><p><pre>
key
</pre></p></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>B</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>C</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>D</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>E</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>F</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
    </tr>
    <tr>
      <td>G</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload certificate request with invalid certificate

#### Setup

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Rotate()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<UploadRequest with invalid certificate>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Success - the certificate has been installed and now can be verified</td>
    </tr>
  </tbody>
</table>

#### Check that the certificate has changed

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4</td>
      <td>Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td>Error: the connection cannot be established due to not-working certificate</td>
    </tr>
  </tbody>
</table>

#### Revert to the last known good state

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5</td>
      <td>Call <code>stream.CloseSend()</code></td>
      <td>Success - the client->server stream is closed</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: EOF</td>
    </tr>
  </tbody>
</table>

#### Check that the switch is reachable again

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>7</td>
      <td>Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td>Success the connection has been established as the incorrect certificate has been reverted.</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload certificate request with valid certificate

<table>
  <thead>
    <tr>
      <th></th>
      <th><br>
This test requires a "real" certificate (and associated private key).<br>
Skip if they are not available!</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>

#### Setup

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Rotate()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<UploadRequest with invalid certificate>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Success - the certificate has been installed and now can be verified</td>
    </tr>
  </tbody>
</table>

#### Check that the certificate has changed

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4</td>
      <td>Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td>Success the connection has been established</td>
    </tr>
  </tbody>
</table>

#### Finalize the change

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5</td>
      <td>Call <code>stream.Send(FinalizeRequest)</code></td>
      <td>Success</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>The connection is closed: Error status/message: EOF</td>
    </tr>
  </tbody>
</table>

#### Check that the switch is still reachable

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>7</td>
      <td>Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td>Success the connection has been established with new credentials</td>
    </tr>
  </tbody>
</table>

### Open stream, send incomplete upload CA trust bundle request

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Rotate()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<incomplete UploadRequest>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: missing information</td>
    </tr>
  </tbody>
</table>

There are 6 fields in the `UploadRequest.Entity `message:

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><p><pre>
id
</pre></p></td>
      <td>A string identifying the entity to be replaced.<br>
Only existing entities can be rotated.<br>
An entity is installed by calling the <code>Install()</code> RPC with a non-existing ID.<br>
In the default configuration it should be <code>ca.</code></td>
    </tr>
    <tr>
      <td><p><pre>
version
</pre></p></td>
      <td>The version of the entity. It has to be unique.</td>
    </tr>
    <tr>
      <td><p><pre>
created_on
</pre></p></td>
      <td>A timestamp of the moment in time when the entity was created.<br>
A good unique version can be generated using the current timestamp.</td>
    </tr>
    <tr>
      <td><p><pre>
trust_bundle.certificate[0].type
</pre></p></td>
      <td>The type of the certificate. For example: CT_X509</td>
    </tr>
    <tr>
      <td><p><pre>
trust_bundle.certificate[0].encoding
</pre></p></td>
      <td>The encoding of the certificate. For example: CE_PEM</td>
    </tr>
    <tr>
      <td><p><pre>
trust_bundle.certificate[0].certificate
</pre></p></td>
      <td>Bytes representing the PEM-encoded certificate</td>
    </tr>
  </tbody>
</table>

This test should validate the following combinations of missing information:

<table>
  <thead>
    <tr>
      <th>case</th>
      <th><p><pre>
id
</pre></p></th>
      <th><p><pre>
version
</pre></p></th>
      <th><p><pre>
created
</pre></p></th>
      <th><p><pre>
type
</pre></p></th>
      <th><p><pre>
enc
</pre></p></th>
      <th><p><pre>
cert
</pre></p></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>B</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>C</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>D</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>E</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
    </tr>
    <tr>
      <td>F</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload CA trust bundle request with invalid bundle
Setup

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
1</td>
      <td><br>
Call <code>gnsi.Rotate()</code></td>
      <td><br>
Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td><br>
2</td>
      <td><br>
Call <code>stream.Send(<UploadRequest with invalid certificate>)</code></td>
      <td><br>
Success - the message was sent</td>
    </tr>
    <tr>
      <td><br>
3</td>
      <td><br>
Call <code>stream.Recv()</code></td>
      <td><br>
Success - the certificate has been installed and now can be verified</td>
    </tr>
  </tbody>
</table>

Check that the CA trust bundle has been activated

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
4</td>
      <td><br>
Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td><br>
Error: the connection cannot be established due to not-working certificate</td>
    </tr>
  </tbody>
</table>

Revert to the last known good state

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
5</td>
      <td><br>
Call <code>stream.CloseSend()</code></td>
      <td><br>
Success - the client->server stream is closed</td>
    </tr>
    <tr>
      <td><br>
6</td>
      <td><br>
Call <code>stream.Recv()</code></td>
      <td><br>
Error status/message: EOF</td>
    </tr>
  </tbody>
</table>

Check that the switch is reachable again

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
7</td>
      <td><br>
Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td><br>
Success the connection has been established as the incorrect certificate has been reverted.</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload CA trust bundle request with valid bundle
Setup

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
1</td>
      <td><br>
Call <code>gnsi.Rotate()</code></td>
      <td><br>
Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td><br>
2</td>
      <td><br>
Call <code>stream.Send(<UploadRequest with valid certificate>)</code></td>
      <td><br>
Success - the message was sent</td>
    </tr>
    <tr>
      <td><br>
3</td>
      <td><br>
Call <code>stream.Recv()</code></td>
      <td><br>
Success - the certificate has been installed and now can be verified</td>
    </tr>
  </tbody>
</table>

Check that the CA trust bundle has been activated

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
4</td>
      <td><br>
Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td><br>
Success the connection has been established</td>
    </tr>
  </tbody>
</table>

Finalize the change

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
5</td>
      <td><br>
Call <code>stream.Send(FinalizeRequest)</code></td>
      <td><br>
Success</td>
    </tr>
    <tr>
      <td><br>
6</td>
      <td><br>
Call <code>stream.Recv()</code></td>
      <td><br>
The connection is closed: Error status/message: EOF</td>
    </tr>
  </tbody>
</table>

Check that the switch is still reachable

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
7</td>
      <td><br>
Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td><br>
Success the connection has been established with new credentials</td>
    </tr>
  </tbody>
</table>

### Open stream, send incomplete upload CRL request

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Rotate()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<incomplete UploadRequest>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: missing information</td>
    </tr>
  </tbody>
</table>

There are 7 fields in the `UploadRequest.Entity `message. This test should validate all combinations of missing information.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><p><pre>
id
</pre></p></td>
      <td>A string identifying the entity to be installed.<br>
Only non-existing entities can be installed.<br>
In the default configuration it cannot be <code>crl</code>.</td>
    </tr>
    <tr>
      <td><p><pre>
version
</pre></p></td>
      <td>The version of the entity. It has to be unique.<br>
A good unique version can be generated using the current timestamp.</td>
    </tr>
    <tr>
      <td><p><pre>
created_on
</pre></p></td>
      <td>A timestamp of the moment in time when the entity was created</td>
    </tr>
    <tr>
      <td><p><pre>
crl_bundle.crl[0].type
</pre></p></td>
      <td>The type of the CRL. For example: CT_X509</td>
    </tr>
    <tr>
      <td><p><pre>
crl_bundle.crl[0].encoding
</pre></p></td>
      <td>The encoding of the CRL. For example: CE_PEM</td>
    </tr>
    <tr>
      <td><p><pre>
crl_bundle.crl[0].crl
</pre></p></td>
      <td>Bytes representing the PEM-encoded certificate revocation list</td>
    </tr>
    <tr>
      <td><p><pre>
crl_bundle.crl[0].id
</pre></p></td>
      <td>An ID of this CRL that allows for identification of the CRL within the CRL bundle</td>
    </tr>
  </tbody>
</table>

This test should validate the following combinations of missing information:

<table>
  <thead>
    <tr>
      <th>case</th>
      <th><p><pre>
id
</pre></p></th>
      <th><p><pre>
version
</pre></p></th>
      <th><p><pre>
created
</pre></p></th>
      <th><p><pre>
type
</pre></p></th>
      <th><p><pre>
enc
</pre></p></th>
      <th><p><pre>
crl
</pre></p></th>
      <th><p><pre>
id
</pre></p></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>B</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>C</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>D</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>E</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>F</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
    </tr>
    <tr>
      <td>G</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload CRL request with invalid bundle

Setup

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
1</td>
      <td><br>
Call <code>gnsi.Rotate()</code></td>
      <td><br>
Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td><br>
2</td>
      <td><br>
Call <code>stream.Send(<UploadRequest with invalid crl>)</code></td>
      <td><br>
Success - the message was sent</td>
    </tr>
    <tr>
      <td><br>
3</td>
      <td><br>
Call <code>stream.Recv()</code></td>
      <td><br>
Success - the certificate has been installed and now can be verified</td>
    </tr>
  </tbody>
</table>

Setup

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
4</td>
      <td><br>
Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td><br>
Error: the connection cannot be established due to not-working certificate</td>
    </tr>
  </tbody>
</table>

Setup

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
5</td>
      <td><br>
Call <code>stream.CloseSend()</code></td>
      <td><br>
Success - the client->server stream is closed</td>
    </tr>
    <tr>
      <td><br>
6</td>
      <td><br>
Call <code>stream.Recv()</code></td>
      <td><br>
Error status/message: EOF</td>
    </tr>
  </tbody>
</table>

Setup

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
7</td>
      <td><br>
Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td><br>
Success the connection has been established as the incorrect certificate has been reverted.</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload CRL request with valid bundle
Setup

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
1</td>
      <td><br>
Call <code>gnsi.Rotate()</code></td>
      <td><br>
Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td><br>
2</td>
      <td><br>
Call <code>stream.Send(<UploadRequest with valid crl>)</code></td>
      <td><br>
Success - the message was sent</td>
    </tr>
    <tr>
      <td><br>
3</td>
      <td><br>
Call <code>stream.Recv()</code></td>
      <td><br>
Success - the certificate has been installed and now can be verified</td>
    </tr>
  </tbody>
</table>

Setup

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
4</td>
      <td><br>
Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td><br>
Success the connection has been established</td>
    </tr>
  </tbody>
</table>

Setup

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
5</td>
      <td><br>
Call <code>stream.Send(FinalizeRequest)</code></td>
      <td><br>
Success</td>
    </tr>
    <tr>
      <td><br>
6</td>
      <td><br>
Call <code>stream.Recv()</code></td>
      <td><br>
The connection is closed: Error status/message: EOF</td>
    </tr>
  </tbody>
</table>

Setup

<table>
  <thead>
    <tr>
      <th><br>
#</th>
      <th><br>
Action</th>
      <th><br>
Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br>
7</td>
      <td><br>
Call <code>gnmi.Get(/interfaces/interface[name="Ethernet0"]/state/mtu)</code></td>
      <td><br>
Success the connection has been established with new credentials</td>
    </tr>
  </tbody>
</table>

## Install()

This RPC is used to install a new (not existing yet) entity (certificate, CA trust bundle or CRL).

Note that the credentials installed using this RPC are not activated after installation. To activate the credentials another (non-existing at the moment) API has to be used. This new API can be part of the gNMI or a console command, etc.

### Open stream and close

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.CloseSend()</code></td>
      <td>Success - the client->server stream is closed</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: premature stream closure</td>
    </tr>
  </tbody>
</table>

### Open stream, send empty request

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<empty request>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: missing information</td>
    </tr>
  </tbody>
</table>

### Open stream, send incomplete upload certificate request

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<incomplete UploadRequest>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: missing information</td>
    </tr>
  </tbody>
</table>

There are 6 fields in the `UploadRequest.Entity `message:

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><p><pre>
id
</pre></p></td>
      <td>A string identifying the entity to be installed.<br>
Only non-existing entities can be installed.<br>
In the default configuration it cannot be "<code>server"</code>.</td>
    </tr>
    <tr>
      <td><p><pre>
version
</pre></p></td>
      <td>The version of the entity. It has to be unique.</td>
    </tr>
    <tr>
      <td><p><pre>
created_on
</pre></p></td>
      <td>A timestamp of the moment in time when the entity was created.<br>
A good unique version can be generated using the current timestamp.</td>
    </tr>
    <tr>
      <td><p><pre>
certificate.type
</pre></p></td>
      <td>The type of the certificate. For example: CT_X509</td>
    </tr>
    <tr>
      <td><p><pre>
certificate.encoding
</pre></p></td>
      <td>The encoding of the certificate. For example: CE_PEM</td>
    </tr>
    <tr>
      <td><p><pre>
certificate.certificate
</pre></p></td>
      <td>Bytes representing the PEM-encoded certificate</td>
    </tr>
    <tr>
      <td><p><pre>
certificate.private_key
</pre></p></td>
      <td>Bytes representing the PEM-encoded private key</td>
    </tr>
  </tbody>
</table>

This test should validate the following combinations of missing information:

<table>
  <thead>
    <tr>
      <th>case</th>
      <th><p><pre>
id
</pre></p></th>
      <th><p><pre>
version
</pre></p></th>
      <th><p><pre>
created
</pre></p></th>
      <th><p><pre>
type
</pre></p></th>
      <th><p><pre>
enc
</pre></p></th>
      <th><p><pre>
cert
</pre></p></th>
      <th><p><pre>
key
</pre></p></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>B</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>C</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>D</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>E</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>F</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
    </tr>
    <tr>
      <td>G</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload certificate request with invalid certificate

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<UploadRequest with invalid certificate>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Success - the certificate has been installed</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: EOF</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload certificate request with valid certificate

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<UploadRequest with valid certificate>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Success - a LoadCertificateResponse is received</td>
    </tr>
  </tbody>
</table>

### Open stream, send incomplete upload CA trust bundle request

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<incomplete UploadRequest>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: missing information</td>
    </tr>
  </tbody>
</table>

There are 6 fields in the `UploadRequest.Entity `message. This test should validate all combinations of missing information.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><p><pre>
id
</pre></p></td>
      <td>A string identifying the entity to be installed.<br>
Only non-existing entities can be installed.<br>
In the default configuration it cannot be "<code>ca"</code>.</td>
    </tr>
    <tr>
      <td><p><pre>
version
</pre></p></td>
      <td>The version of the entity. It has to be unique.<br>
A good unique version can be generated using the current timestamp.</td>
    </tr>
    <tr>
      <td><p><pre>
created_on
</pre></p></td>
      <td>A timestamp of the moment in time when the entity was created</td>
    </tr>
    <tr>
      <td><p><pre>
trust_bundle.certificate[0].type
</pre></p></td>
      <td>The type of the certificate. For example: CT_X509</td>
    </tr>
    <tr>
      <td><p><pre>
trust_bundle.certificate[0].encoding
</pre></p></td>
      <td>The encoding of the certificate. For example: CE_PEM</td>
    </tr>
    <tr>
      <td><p><pre>
trust_bundle.certificate[0].certificate
</pre></p></td>
      <td>Bytes representing the PEM-encoded certificate</td>
    </tr>
  </tbody>
</table>

This test should validate the following combinations of missing information:

<table>
  <thead>
    <tr>
      <th>case</th>
      <th><p><pre>
id
</pre></p></th>
      <th><p><pre>
version
</pre></p></th>
      <th><p><pre>
created
</pre></p></th>
      <th><p><pre>
type
</pre></p></th>
      <th><p><pre>
enc
</pre></p></th>
      <th><p><pre>
cert
</pre></p></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>B</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>C</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>D</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>E</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
    </tr>
    <tr>
      <td>F</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload CA trust bundle request with invalid bundle

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<UploadRequest with invalid trust bundle>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Success - the certificate has been installed</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: EOF</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload CA trust bundle request with valid bundle

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<UploadRequest with valid trust bundle>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Success - a LoadCertificateResponse is received</td>
    </tr>
  </tbody>
</table>

### Open stream, send incomplete upload CRL request

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<incomplete UploadRequest>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: missing information</td>
    </tr>
  </tbody>
</table>

There are 7 fields in the `UploadRequest.Entity `message. This test should validate all combinations of missing information.

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><p><pre>
id
</pre></p></td>
      <td>A string identifying the entity to be installed.<br>
Only non-existing entities can be installed.<br>
In the default configuration it cannot be "<code>crl"</code>.</td>
    </tr>
    <tr>
      <td><p><pre>
version
</pre></p></td>
      <td>The version of the entity. It has to be unique.<br>
A good unique version can be generated using the current timestamp.</td>
    </tr>
    <tr>
      <td><p><pre>
created_on
</pre></p></td>
      <td>A timestamp of the moment in time when the entity was created</td>
    </tr>
    <tr>
      <td><p><pre>
crl_bundle.crl[0].type
</pre></p></td>
      <td>The type of the CRL. For example: CT_X509</td>
    </tr>
    <tr>
      <td><p><pre>
crl_bundle.crl[0].encoding
</pre></p></td>
      <td>The encoding of the CRL. For example: CE_PEM</td>
    </tr>
    <tr>
      <td><p><pre>
crl_bundle.crl[0].crl
</pre></p></td>
      <td>Bytes representing the PEM-encoded certificate revocation list</td>
    </tr>
    <tr>
      <td><p><pre>
crl_bundle.crl[0].id
</pre></p></td>
      <td>An ID of this CRL that allows for identification of the CRL within the CRL bundle</td>
    </tr>
  </tbody>
</table>

This test should validate the following combinations of missing information:

<table>
  <thead>
    <tr>
      <th>case</th>
      <th><p><pre>
id
</pre></p></th>
      <th><p><pre>
version
</pre></p></th>
      <th><p><pre>
created
</pre></p></th>
      <th><p><pre>
type
</pre></p></th>
      <th><p><pre>
enc
</pre></p></th>
      <th><p><pre>
crl
</pre></p></th>
      <th><p><pre>
id
</pre></p></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>B</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>C</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>D</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>E</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
      <td>+</td>
    </tr>
    <tr>
      <td>F</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
      <td>+</td>
    </tr>
    <tr>
      <td>G</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>+</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload CRL request with invalid bundle

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<UploadRequest with invalid crl>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Success - the certificate has been installed</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Error status/message: EOF</td>
    </tr>
  </tbody>
</table>

### Open stream, send upload CRL request with valid bundle

<table>
  <thead>
    <tr>
      <th>#</th>
      <th>Action</th>
      <th>Expectation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Call <code>gnsi.Install()</code></td>
      <td>Success - the <code>stream</code> is open</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Call <code>stream.Send(<UploadRequest with valid crl>)</code></td>
      <td>Success - the message was sent</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Call <code>stream.Recv()</code></td>
      <td>Success - a LoadCertificateResponse is received</td>
    </tr>
  </tbody>
</table>
